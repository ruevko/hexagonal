---
title: Caracterización del COVID-19 en Ecuador
author: Rafael Castro
date: '2020-03-20'
slug: 20-caracterizacion-covid-ecuador
categories:
  - Reportes
tags:
  - coronavirus
  - regresión
keywords:
  - coronavirus
  - regression

link-citations: true
bibliography: '../../babel.bib'
coverImage: 'https://github.com/ruevko/hexagonal/raw/master/content/post/2020/03/ec_covid19.jpg' 
summary: Utilizando paquetes desarrollados por el R Epidemics Consortium, se estima el ritmo reproductivo básico y se proyectan tres escenarios futuros para los casos positivos acumulados diariamente.
---

**Actualizado: 25 de marzo, 12 AM**

En vista de la emergencia en curso causada por el SARS-CoV-2 se presenta una caracterización de la epidemia en Ecuador. Se ha aplicado una metodología sugerida por el R Epidemics Consortium [RECON](https://www.repidemicsconsortium.org/) que permite estimar tempranamente el ritmo reproductivo del virus; esta metodología requiere poseer información sobre la transmisión, y datos de la incidencia. La información requerida contempla los siguientes conceptos:

`r knitr::opts_chunk$set(echo = FALSE)`

* El ritmo reproductivo básico (*Basic Reproduction Number*, R~0~) es el número esperado de casos nuevos, generados directamente por un determinado caso en una población completamente susceptible; es crucial entender que R~0~ no es una constante biológica de un patógeno, pues es afectado por factores ambientales y conductuales.

* El intervalo serial (*Serial Interval*, SI) es el tiempo transcurrido entre casos sucesivos en una misma cadena de transmisión; es posible caracterizar al SI con una distribución *Gamma*, conociendo su media y desviación estándar en días; no confundir el SI con:

    + El periodo de incubación, entre una infección y la aparición de sus síntomas.

    + El periodo latente, entre una infección y el comienzo del periodo infeccioso.

    + En el periodo infeccioso, una persona infectada puede causar nuevas infecciones.

```{r data}
EC_COVID19 = data.frame(
   fuente = c(rep("Salud_Ec", 9), rep("Riesgos_Ec", 21)),
   status = c(
      "1233774191326957575",
      "1234331734889697281",
      "1234670644878462980",
      "1235224139348271105",
      "1235576943967449088",
      "1236101438834696195",
      "1236830188102733828",
      "1237506194740109313",
      "1238238472563032067",
      "1238572655269330946",  #01
      "1238647701522321409",  #02
      "1238941268098592775",  #03
      "1239228487673810948",  #04
      "1239367431023407107",  #05
      "1239581710729326595",  #06
      "1239678775610216449",  #07
      "1239948244878348288",  #08
      "1240250490912374785",  #10
      "1240399748751900674",  #11
      "1240655168158515200",  #12
      "1240750001917243392",  #13
      "1241018222079610881",  #14
      "1241123691427176450",  #15
      "1241379969797967883",  #16
      "1241485101780926465",  #17
      "1241761146643853313",  #18
      "1242105767366406150",  #19
      "1242467589147758592",  #20
      "1242581856891146243",  #21
      "1242834504324128775"), #22
   sitrep = c(rep(NA, 9), 1:8, 10:22),
   corte = as.POSIXct(c(
      "2020-02-29 10:02",
      "2020-03-01 23:02",
      "2020-03-02 22:01",
      "2020-03-04 10:01",
      "2020-03-05 09:31",
      "2020-03-06 20:01",
      "2020-03-08 21:01",
      "2020-03-10 16:30",
      "2020-03-12 18:01",
      "2020-03-13 15:00",  #01
      "2020-03-13 17:00",  #02
      "2020-03-14 15:00",  #03
      "2020-03-15 09:00",  #04
      "2020-03-15 18:00",  #05
      "2020-03-16 09:00",  #06
      "2020-03-16 16:00",  #07
      "2020-03-17 08:00",  #08
      "2020-03-18 05:00",  #10
      "2020-03-18 15:00",  #11
      "2020-03-19 08:00",  #12
      "2020-03-19 16:00",  #13
      "2020-03-20 10:00",  #14
      "2020-03-20 16:00",  #15
      "2020-03-21 10:00",  #16
      "2020-03-21 17:00",  #17
      "2020-03-22 10:00",  #18
      "2020-03-23 10:00",  #19
      "2020-03-24 10:00",  #20
      "2020-03-24 17:00",  #21
      "2020-03-25 10:00"), #22
      "America/Guayaquil"),
   cerco = c(rep(NA, 9), 279, 279, 317, 273, 273, 273, 315, 451, NA, 575,
             575, 746, 746, 1213, 1213, 1213, 1347, 1347, 1347, NA, NA),
   negativo = c(rep(NA, 12), 51, 51, 51, 51, 51, 278, 312, 336, 412,
                483, 533, 601, 649, 872, 1091, 1211, 1225, 1346),
   positivo = c(1, 6, 7, 10, 13, 14, 15, 17, 19, 23, 23, 28, 37, 37, 58, 58, 111,
                155, 168, 199, 260, 367, 426, 506, 532, 789, 981, 1049, 1082, 1173),
   fallecido = c(rep(0, 9), 1, 1, rep(2, 7), 3, 3, 4, 5, 7, 7, 7, 14, 18, 27, 27, 28))

write.csv(EC_COVID19, "EC_COVID19.csv", row.names = FALSE)

#EC_COVID19 = read.csv("EC_COVID19.csv", colClasses = c(status = "character", corte = "POSIXct"))
```

Si las infecciones ocurren aleatoriamente, se espera que el SI promedio sea igual a la suma del periodo latente promedio y la mitad del periodo infeccioso promedio. Por otra parte, el periodo latente no siempre es mayor que el de incubación: dependiendo del virus, una persona puede volverse infecciosa antes de presentar síntomas. En el caso del SARS-CoV-2, se halló que su periodo de incubación posee una mediana de siete días [@covid], pero el periodo infeccioso puede comenzar un día antes. Este gráfico (que no representa necesariamente un caso de SARS-CoV-2) permite visualizar la relación existente entre los conceptos mencionados:

```{r explain, dev="svg", fig.dim=c(9,2.4)}
library(ggplot2)

dias = data.frame(d = c(1, 5, 7, 10, 15), v0 = 0, v1 = 5, v2 = c(
   "A infecta a B", "B se vuelve\ninfeccioso", "B presenta\nsíntomas",
   "B infecta a C", "B ya no es\ninfeccioso"))

peri = dplyr::mutate(data.frame(x0 = c(1, 5, 1, 1), x1 = c(10, 15, 5, 7), y0 = c(3, 1, 1, 2), y2 = c(
   "Intervalo\nSerial", "Periodo\nInfeccioso", "Periodo\nLatente", "Periodo de\nIncubación")),
   y1 = y0, x2 = (x0+x1)/2, y2 = forcats::fct_inorder(y2))

ggplot(dias, aes(d, v1, label = v2)) + coord_cartesian(expand = FALSE) +
   geom_hline(yintercept = 0, size = 2) + geom_linerange(aes(ymin = v0, ymax = v1)) +
   geom_point(size = 1.5) + geom_point(aes(y = v0), size = 3) +
   geom_text(hjust = 0, vjust = 1, nudge_x = .2, nudge_y = .2) +
   scale_x_continuous("Días", 0:17, limits = c(0, 17)) + scale_y_continuous(breaks = NULL) +
   theme(axis.title.y=element_blank(), panel.background=element_blank(), legend.position="none") +
   geom_text(aes(x2, y0, label = y2, col = y2), peri, nudge_y=.05, fontface=2, inherit.aes=FALSE) +
   geom_segment(aes(x0, y0, xend = x1, yend = y1, col = y2), peri, size = 1, inherit.aes = FALSE,
                arrow = arrow(20, ends = "both")) + ggthemes::scale_color_gdocs()
```

Con respecto a los datos, se ha recopilado los reportes publicados por el Servicio Nacional de Gestión de Riesgos [SNGRE](https://twitter.com/Riesgos_Ec); casos anteriores al primer reporte corresponden a comunicados del Ministerio de Salud Pública [MSP](https://twitter.com/Salud_Ec).

```{r table}
EC_COVID19 = EC_COVID19[-c(11, 14, 16, 19, 21, 23, 25, 29), c(1, 4, 7, 8)]

library(kableExtra)

dplyr::mutate(EC_COVID19, corte = as.character(corte, "%e de %B, %l %p")) %>%
   dplyr::arrange(desc(positivo)) %>% kable(row.names = FALSE, col.names = c(
      "Fuente", "Fecha de corte", "Casos positivos", "Personas fallecidas")) %>%
   scroll_box("280px")

# EC_table = DT::datatable(EC_table, options = list(
#    pageLength = 7, lengthChange = FALSE, searching = FALSE, fig.height=3.7
#    language = list(url = '//cdn.datatables.net/plug-ins/1.10.11/i18n/Spanish.json')),
#    colnames=c("Fuente","Fecha de corte","Casos positivos","Personas fallecidas"))
# widgetframe::frameWidget(EC_table, height = 370)
```

Los datos completos, incluyendo los casos descartados y algunos reportes omitidos (en los días con dos reportes se escogió el matutino), se encuentran [aquí](https://github.com/ruevko/hexagonal/blob/master/content/post/2020/03/EC_COVID19.csv). El primer paso para estimar R~0~ consiste en transformar los casos positivos acumulados en incidencia diaria:

```{r incidence, echo=TRUE}
EC_COVID19$corte = as.Date(EC_COVID19$corte)

EC_COVID19$positivo = diff(c(0, EC_COVID19$positivo))

EC_incid = rep(EC_COVID19$corte, EC_COVID19$positivo)

table(EC_incid)
```

A continuación es posible ajustar un modelo logarítmico para la incidencia en el tiempo utilizando el paquete `incidence`:

```{r logmodel, echo=TRUE}
library(incidence)

EC_incid = incidence(EC_incid)

EC_model = fit(EC_incid[8:23]) # del 7 al 22 de marzo

EC_model$model
```

En Ecuador, el comportamiento logarítmico (R^2^ = `r round(summary(EC_model$model)$r.squared, 4)`) se observó  del 7 de marzo -una semana después de detectado el primer caso- al 22 de marzo. En ese periodo los casos se duplicaron cada `r round(EC_model$info$doubling, 2)` días; esto, con un intervalo de confianza (CI) al 95 % de `r paste(round(EC_model$info$doubling.conf, 2), collapse = " a ")` días. Después de eso, la incidencia diaria es difícil de modelar; esto se podría relacionar tanto con las medidas de emergencia adoptadas, como con dudas sobre la veracidad de los datos. En el siguiente gráfico las columnas rojas representan la incidencia diaria, la curva el modelo logarítmico -las líneas entrecortadas delimitan el 95 % CI- y la recta amarilla el inicio del estado de excepción, decretado para frenar las transmisiones.

```{r logplot, fig.asp=.5, fig.cap="Incidencia diaria de COVID-19 en Ecuador y modelo logarítmico ajustado"}
ggsave("ec_covid19.jpg", dpi = "screen", width = 16, height = 7.925, plot = {
   plot(EC_incid) + theme_minimal() + scale_y_sqrt(breaks = 50*0:9) +
   scale_x_date(date_breaks = "2 days", date_labels = "%b %e") +
   theme(plot.background = element_rect(fill = "grey15"),
         panel.grid = element_line("grey25"),
         text = element_text(size = 25),
         title = element_blank())})

theme_set(theme_light() + theme(legend.position = "none", axis.title.x = element_blank()))

plot(EC_incid, fit = EC_model) +
   scale_fill_manual(values = "firebrick") +
   scale_x_date(date_breaks = "2 days", date_labels = "%b %e") +
   scale_y_continuous("Incidencia diaria", breaks = 50 * 0:9) +
   geom_vline(xintercept = as.Date("2020-03-17"), col = "gold", alpha = .6, size = 2)
```

La estimación de R~0~ con `earlyR` requiere conocer el SI del COVID-19; en este sentido, la literatura reciente presenta dos alternativas. La primera, aprovechar el conocimiento de epidemias anteriores; @covia proponen promediar las características del MERS (mean = 7.6, sd = 3.4) y del SARS (mean = 8.4, sd = 3.8), síndromes causados por otros coronavirus. La segunda alternativa consiste en estimar el SI utilizando las pocas cadenas de transmisión ya identificadas [@covib; @covic]; de esta manera se obtiene un SI preliminar, pero propio del SARS-CoV-2.

Con estos antecedentes, se estimó `R_viruses` y `R_chains` usando la primera y segunda alternativa, respectivamente; se consideró la incidencia hasta el 22 de marzo, el pico actual de casos nuevos. Los siguientes histogramas presentan la distribución de los R~0~ calculados.

```{r number, echo=TRUE, dev="svg", fig.asp=.35, fig.cap="Distribución de Ro del COVID-19 según SI de otros coronavirus :point_left: y de cadenas de transmisión estudiadas :point_right:"}
library(earlyR)

R_viruses = get_R(EC_incid[1:23], si_mean = 8, si_sd = 3.6, max_R = 6) # Zhao, Lin et al.

R_chains = get_R(EC_incid[1:23], si_mean = 4.4, si_sd = 3, max_R = 6) # Zhao, Gao et al.

par(mfrow = c(1, 2), mar = c(4, 5, 1, 1))

hist(sample_R(R_viruses, 1e3), freq = FALSE, main = NULL, xlab = "R_viruses")

hist(sample_R(R_chains, 1e3), freq = FALSE, main = NULL, xlab = "R_chains")
```

La primera alternativa arroja `r round(R_viruses$R_ml, 2)` como el valor más probable; es posible considerar este valor una sobrestimación de R~0~ según lo observado en estudios recientes. Mientras tanto, la segunda alternativa estima un R~0~ = `r round(R_chains$R_ml, 2)` (95 % CI: `r R_sample = sample_R(R_chains, 1e4); quantile(R_sample, c(.025, .975)) %>% round(2) %>% paste(collapse = " - ")`); un valor congruente con los estudios, donde se ha observado que el SARS-CoV-2 posee un SI más corto que otros coronavirus. Por ende, aun con un ritmo reproductivo menor, puede generar más casos.

Considerando R~0~ se puede modelar una proyección futura, más flexible que la arrojada por el modelo exponencial solamente. Se ha utilizado `projections` para predecir tres escenarios, calculando en cada uno diez mil simulaciones para cada día de las próximas dos semanas.

```{r project, echo=TRUE}
library(projections)

EC_proj = project(EC_incid[1:23], R_sample, R_chains$si, n_days = 14, n_sim = 1e4)

rowMeans(EC_proj)
```

Estos datos representan la incidencia promedio para cada día, en un primer escenario donde R~0~ no cambia en absoluto. Los casos actuales y la proyección futura -la región sombreada delimita el 95 % CI- se presentan en el siguiente gráfico de manera acumulativa:

```{r project-normal, echo=TRUE, fig.asp=.5, fig.cap=paste("Proyección de incidencia diaria acumulada de COVID-19 en Ecuador si R0 =", round(R_chains$R_ml, 2))}
EC_incid = cumulate(EC_incid)

EC_proj = cumulate(EC_proj) + max(EC_incid[1:23]$counts)

add_projections(plot(EC_incid), EC_proj, c(.025, .5)) +
   geom_vline(xintercept = as.Date("2020-03-17"), col = "gold", alpha = .6, size = 2) +
   scale_y_continuous("Incidencia diaria acumulada", 2e3 * 0:9) +
   scale_x_date(date_breaks = "4 days", date_labels = "%b %e") +
   scale_fill_manual(values = "firebrick")
```

El segundo y tercer escenarios calculados suponen que R~0~ se reduce a la mitad (figura \@ref(fig:project-better)) y a la quinta parte (figura \@ref(fig:project-best)), respectivamente:

```{r project-better, fig.asp=.5, fig.cap=paste("Proyección de incidencia diaria acumulada de COVID-19 en Ecuador si R0 =", round(R_chains$R_ml/2, 2))}
EC_proj = project(EC_incid[1:23], R_chains$R_ml/2, R_chains$si, 1e4, 14) %>% cumulate()

plot(EC_incid) %>% add_projections(EC_proj + max(EC_incid[1:23]$counts), c(.025, .5)) +
   geom_vline(xintercept = as.Date("2020-03-17"), col = "gold", alpha = .6, size = 2) +
   scale_y_continuous("Incidencia diaria acumulada", 500 * 0:15) +
   scale_x_date(date_breaks = "4 days", date_labels = "%b %e") +
   scale_fill_manual(values = "firebrick")

#rowMeans(EC_proj) + max(EC_incid$counts)
```

```{r project-best, fig.asp=.5, fig.cap=paste("Proyección de incidencia diaria acumulada de COVID-19 en Ecuador si R0 =", round(R_chains$R_ml/5, 2))}
EC_proj = project(EC_incid[1:23], R_chains$R_ml/5, R_chains$si, 1e4, 14) %>% cumulate()

plot(EC_incid) %>% add_projections(EC_proj + max(EC_incid[1:23]$counts), c(.025, .5)) +
   geom_vline(xintercept = as.Date("2020-03-17"), col = "gold", alpha = .6, size = 2) +
   scale_y_continuous("Incidencia diaria acumulada", 250 * 0:9) +
   scale_x_date(date_breaks = "4 days", date_labels = "%b %e") +
   scale_fill_manual(values = "firebrick")

#rowMeans(EC_proj) + max(EC_incid$counts)
```

Evidentemente, si R~0~ < 1 la epidemia será controlada eventualmente. Sin embargo, **estas proyecciones no son realistas** pues cualquier cambio introducido en R~0~ -a través de medidas políticas, sociales y sanitarias-  no se refleja inmediatamente; en Ecuador es necesario contar las infecciones previas a la declaración de estado de excepción, y que aún no han superado el periodo de incubación. Se pretende actualizar este post conforme las incidencias diarias sean reportadas y reflejen, con optimismo, las medidas adoptadas.

# Referencias
