---
title: "Enhancin' our Web Scrapin'"
date: 2021-03-10
slug: enhancing-web-scraping
categories: [OpenStreetMap]
tags:
  - benchmark
  - web scraping
thumbnailImage: https://ruevko.github.io/hexagonal/post/2021/03/10-mejorando-nuestro-scraping_files/figure-html/parsing-bmark-1.png
summary: "There've been changes in OSMstats, the website from which we obtained OpenStreetMap statistics; this is an opportunity to introduce `rvest` and obtain such data more easily."
---

<style type="text/css">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    background-color: #ffffff;
    color: #a0a0a0;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #a0a0a0;  padding-left: 4px; }
div.sourceCode
  { color: #1f1c1b; background-color: #ffffff; }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span. { color: #1f1c1b; } /* Normal */
code span.al { color: #bf0303; background-color: #f7e6e6; font-weight: bold; } /* Alert */
code span.an { color: #ca60ca; } /* Annotation */
code span.at { color: #0057ae; } /* Attribute */
code span.bn { color: #b08000; } /* BaseN */
code span.bu { color: #644a9b; font-weight: bold; } /* BuiltIn */
code span.cf { color: #1f1c1b; font-weight: bold; } /* ControlFlow */
code span.ch { color: #924c9d; } /* Char */
code span.cn { color: #aa5500; } /* Constant */
code span.co { color: #898887; } /* Comment */
code span.cv { color: #0095ff; } /* CommentVar */
code span.do { color: #607880; } /* Documentation */
code span.dt { color: #0057ae; } /* DataType */
code span.dv { color: #b08000; } /* DecVal */
code span.er { color: #bf0303; text-decoration: underline; } /* Error */
code span.ex { color: #0095ff; font-weight: bold; } /* Extension */
code span.fl { color: #b08000; } /* Float */
code span.fu { color: #644a9b; } /* Function */
code span.im { color: #ff5500; } /* Import */
code span.in { color: #b08000; } /* Information */
code span.kw { color: #1f1c1b; font-weight: bold; } /* Keyword */
code span.op { color: #1f1c1b; } /* Operator */
code span.ot { color: #006e28; } /* Other */
code span.pp { color: #006e28; } /* Preprocessor */
code span.re { color: #0057ae; background-color: #e0e9f8; } /* RegionMarker */
code span.sc { color: #3daee9; } /* SpecialChar */
code span.ss { color: #ff5500; } /* SpecialString */
code span.st { color: #bf0303; } /* String */
code span.va { color: #0057ae; } /* Variable */
code span.vs { color: #bf0303; } /* VerbatimString */
code span.wa { color: #bf0303; } /* Warning */
</style>

<p>In this post we will fix the <em>web scraping</em> methodology I previously used
to obtain, from <a href="https://osmstats.neis-one.org">OSMstats</a>, the number of
OpenStreetMap nodes created each day, in each country. Neis Pascal, who maintains
this website, introduced last year some enhancements that broke the operation of
<a href="https://ruevko.github.io/hexagonal/post/2020/01/07-estimando-nodos-openstreetmap-pais/#cb1-1"><code>get_day()</code></a>, a function I designed. So this time we will introduce a R
package, <code>rvest</code>, in order to simplify the whole process; also, we will quantify the
improvement with <em>benchmarks</em>.</p>
<p>In <code>get_day()</code> I used the <code>httr</code> package to connect to a
webpage —which in reality is a HTML document— and get its content. Objects created
by <code>httr::content()</code> are  of <code>xml_document</code> class.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a>osmstats =<span class="st"> &quot;https://osmstats.neis-one.org/?item=countries&amp;date=1-3-2021&quot;</span></span>
<span id="cb1-2"><a href="#cb1-2"></a></span>
<span id="cb1-3"><a href="#cb1-3"></a>(<span class="dt">httr_doc =</span> httr<span class="op">::</span><span class="kw">content</span>(httr<span class="op">::</span><span class="kw">GET</span>(osmstats), <span class="st">&quot;parsed&quot;</span>, <span class="dt">encoding =</span> <span class="st">&quot;UTF-8&quot;</span>))</span></code></pre></div>
<pre><code>## {html_document}
## &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot;&gt;
## [1] &lt;head&gt;\n&lt;title&gt;OSMstats - Statistics of the free wiki world map&lt;/title&gt;\n ...
## [2] &lt;body&gt;\n\t\n&lt;script language=&quot;javascript&quot;&gt;function weekendArea(axes) {var ...</code></pre>
<p>A <code>xml_document</code> is like a copy of the online page, with exactly the same
structure of <em>tags</em><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.
OSMstats has a page for each day —since November 1 of 2011— with the activity
for 260 territories around the world. What we want to do is extract from any page (i.e.
for any date) a <em>tag</em> of type <code>&lt;table&gt;</code>: a table indeed, with
the nodes created, modified, and deleted that date. The screenshot below depicts such a
table, corresponding<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>
to March 1 of 2021.</p>
<div class="figure"><span id="fig:screen"></span>
<img src="https://res.cloudinary.com/dodnzqhiz/image/upload/v1615391078/2021post/dpn3dfjlsdgeycxixttu.png" alt="The `&lt;table&gt;` tag in a OSMstats webpage"  />
<p class="caption">
Figure 1: The <code>&lt;table&gt;</code> tag in a OSMstats webpage
</p>
</div>
<p>Originally I had used <code>xml2::as_list()</code> to convert the <code>xml_document</code>
into a typicial R list; then, I queried the list looking for the <code>&lt;table&gt;</code>
<em>tag</em>, and converted each of its children into a matrix's row. These steps were
accomplished with specially designed functions:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a>pluck_xml =<span class="st"> </span><span class="cf">function</span>(x) x<span class="op">$</span>html<span class="op">$</span>body[[<span class="dv">12</span>]][[<span class="dv">14</span>]]<span class="op">$</span>div<span class="op">$</span>table[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb3-2"><a href="#cb3-2"></a></span>
<span id="cb3-3"><a href="#cb3-3"></a>row_xml =<span class="st"> </span><span class="cf">function</span>(x) <span class="kw">matrix</span>(</span>
<span id="cb3-4"><a href="#cb3-4"></a>  <span class="kw">c</span>( x[[<span class="dv">2</span>]][[<span class="dv">1</span>]][[<span class="dv">1</span>]], x[[<span class="dv">4</span>]][[<span class="dv">1</span>]], x[[<span class="dv">6</span>]][[<span class="dv">1</span>]], x[[<span class="dv">8</span>]][[<span class="dv">1</span>]], x[[<span class="dv">10</span>]][[<span class="dv">1</span>]] ), <span class="dv">1</span>)</span></code></pre></div>
<p>These functions can be used like this:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">library</span>(purrr)</span>
<span id="cb4-2"><a href="#cb4-2"></a></span>
<span id="cb4-3"><a href="#cb4-3"></a>httr_table =<span class="st"> </span>xml2<span class="op">::</span><span class="kw">as_list</span>(httr_doc) <span class="op">%&gt;%</span></span>
<span id="cb4-4"><a href="#cb4-4"></a><span class="st">   </span><span class="kw">pluck_xml</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map</span>(row_xml) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">reduce</span>(rbind)</span>
<span id="cb4-5"><a href="#cb4-5"></a></span>
<span id="cb4-6"><a href="#cb4-6"></a>table_names =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;country&quot;</span>, <span class="st">&quot;contributors&quot;</span>, <span class="st">&quot;created_e&quot;</span>, <span class="st">&quot;modified_e&quot;</span>, <span class="st">&quot;deleted_e&quot;</span>)</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="kw">colnames</span>(httr_table) =<span class="st"> </span>table_names; <span class="kw">head</span>(httr_table)</span></code></pre></div>
<pre><code>##      country       contributors created_e modified_e deleted_e
## [1,] &quot;Puerto Rico&quot; &quot;1 (0%)&quot;     &quot;53&quot;      &quot;15&quot;       &quot;2&quot;
## [2,] &quot;Liberia&quot;     &quot;1 (0%)&quot;     &quot;9464&quot;    &quot;1695&quot;     &quot;1852&quot;
## [3,] &quot;Vanuatu&quot;     &quot;1 (0%)&quot;     &quot;0&quot;       &quot;4&quot;        &quot;0&quot;
## [4,] &quot;Curaçao&quot;     &quot;1 (0%)&quot;     &quot;5&quot;       &quot;2&quot;        &quot;6&quot;
## [5,] &quot;Cape Verde&quot;  &quot;1 (0%)&quot;     &quot;12&quot;      &quot;25&quot;       &quot;1&quot;
## [6,] &quot;Mauritius&quot;   &quot;1 (0%)&quot;     &quot;0&quot;       &quot;3&quot;        &quot;0&quot;</code></pre>
<p>If the code I've presented up to now is difficult to understand, it doesn't matter. Because
now I will show how with <code>rvest</code> it is possible to do the same, in an easier manner;
this package is built upon <code>httr</code> y <code>xml2</code>, so it also works with
<code>xml_document</code> objects. This time, we will obtain the content of the target webpage
via <code>rvest::read_html()</code>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">library</span>(rvest)</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a>rvest_doc =<span class="st"> </span><span class="kw">read_html</span>(osmstats, <span class="dt">encoding =</span> <span class="st">&quot;UTF-8&quot;</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a></span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="kw">identical</span>(httr_doc, rvest_doc) <span class="co"># documents obtained via httr and rvest seem different</span></span></code></pre></div>
<pre><code>## [1] FALSE</code></pre>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">identical</span>(<span class="kw">as_list</span>(httr_doc), <span class="kw">as_list</span>(rvest_doc)) <span class="co"># but their contents are identical</span></span></code></pre></div>
<pre><code>## [1] TRUE</code></pre>
<p>Once we get the document, we can extract the <code>&lt;table&gt;</code> with
<code>rvest::html_node()</code>. This function offers two options to specify the query for a <em>tag</em>,
and returns it as a <code>xml_node</code><a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a>
object. First option is to write a CSS<a href="#fn4" class="footnote-ref" id="fnref4"><sup>4</sup></a>
<em>selector</em> that precisely targets the <em>tag</em> we want.</p>
<p>Looking at the screenshot above (figure <a href="#fig:screen">1</a>), the table <em>tag</em>
is written <code>&lt;table id="countrytable"&gt;</code>; since it is the only <em>tag</em>
with that <code>id</code> in the whole page —it is the only table, by the way— we can specify the
following <em>selector</em>:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1"></a><span class="kw">library</span>(dplyr)</span>
<span id="cb10-2"><a href="#cb10-2"></a></span>
<span id="cb10-3"><a href="#cb10-3"></a><span class="kw">html_node</span>(rvest_doc, <span class="st">&quot;#countrytable&quot;</span>) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">html_table</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as_tibble</span>()</span></code></pre></div>
<pre><code>## # A tibble: 260 x 6
##      No. Country    `Contributors (organis~ `Created element~ `Modified element~
##    &lt;dbl&gt; &lt;chr&gt;      &lt;chr&gt;                               &lt;int&gt;              &lt;int&gt;
##  1     1 Puerto Ri~ 1 (0%)                                 53                 15
##  2     2 Liberia    1 (0%)                               9464               1695
##  3     3 Vanuatu    1 (0%)                                  0                  4
##  4     4 Curaçao    1 (0%)                                  5                  2
##  5     5 Cape Verde 1 (0%)                                 12                 25
##  6     6 Mauritius  1 (0%)                                  0                  3
##  7     7 Oman       1 (0%)                                  0                  3
##  8     8 Jordan     1 (0%)                                 47                 10
##  9     9 Monaco     1 (0%)                                  0                  1
## 10    10 Haiti      1 (0%)                                216                201
## # ... with 250 more rows, and 1 more variable: Deleted elements &lt;int&gt;</code></pre>
<p>In the last code line, the extracted <code>xml_node</code> is inserted into
<code>html_table()</code> and the result is a <code>data.frame</code> with the OpenStreetMap
activity of the requested date. And that's it: with just three <code>rvest</code> functions
we have simplified the old methodology. Almost certainly, these functions have been optimized
for fast execution. Therefore, I am going to perform a <em>benchmark</em> to quantify
the enhancement in speed; to begin, I define a function that contains my old table
parsing method, and another one for the new one (<code>parse_old()</code> and
<code>parse_rvest()</code> respectively):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1"></a>parse_rvest =<span class="st"> </span><span class="cf">function</span>(doc) <span class="kw">html_table</span>(<span class="kw">html_node</span>(doc, <span class="st">&quot;#countrytable&quot;</span>))[<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb12-2"><a href="#cb12-2"></a></span>
<span id="cb12-3"><a href="#cb12-3"></a>parse_old =<span class="st"> </span><span class="cf">function</span>(doc) <span class="kw">as_list</span>(doc) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">pluck_xml</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">map</span>(row_xml) <span class="op">%&gt;%</span></span>
<span id="cb12-4"><a href="#cb12-4"></a><span class="st">   </span><span class="kw">reduce</span>(rbind) <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">as.data.frame</span>() <span class="op">%&gt;%</span><span class="st"> </span><span class="kw">set_names</span>(table_names) <span class="op">%&gt;%</span></span>
<span id="cb12-5"><a href="#cb12-5"></a><span class="st">   </span><span class="kw">mutate</span>(<span class="kw">across</span>(<span class="kw">ends_with</span>(<span class="st">&quot;_e&quot;</span>), as.numeric))</span>
<span id="cb12-6"><a href="#cb12-6"></a></span>
<span id="cb12-7"><a href="#cb12-7"></a><span class="kw">summary</span>(<span class="kw">parse_rvest</span>(rvest_doc) <span class="op">==</span><span class="st"> </span><span class="kw">parse_old</span>(rvest_doc)) <span class="co"># identical tables generated</span></span></code></pre></div>
<pre><code>##  Country        Contributors (organised) Created elements Modified elements
##  Mode:logical   Mode:logical             Mode:logical     Mode:logical
##  TRUE:260       TRUE:260                 TRUE:260         TRUE:260
##  Deleted elements
##  Mode:logical
##  TRUE:260</code></pre>
<p>Next, I put both functions inside <code>microbenchmark()</code>:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb14-1"><a href="#cb14-1"></a><span class="kw">library</span>(microbenchmark)</span>
<span id="cb14-2"><a href="#cb14-2"></a></span>
<span id="cb14-3"><a href="#cb14-3"></a>(<span class="dt">parsing_bmark =</span> <span class="kw">microbenchmark</span>(<span class="kw">parse_rvest</span>(rvest_doc), <span class="kw">parse_old</span>(rvest_doc)))</span></code></pre></div>
<pre><code>## Unit: milliseconds
##                    expr   min    lq  mean median    uq   max neval
##  parse_rvest(rvest_doc) 158.4 168.6 173.4  173.4 177.7 188.5   100
##    parse_old(rvest_doc) 326.2 354.8 368.2  366.0 377.8 442.6   100</code></pre>
<div class="sourceCode" id="cb16"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb16-1"><a href="#cb16-1"></a><span class="kw">boxplot</span>(<span class="kw">filter</span>(parsing_bmark, time <span class="op">&lt;</span><span class="st"> </span><span class="fl">4.5e8</span>),</span>
<span id="cb16-2"><a href="#cb16-2"></a>        <span class="dt">main =</span> <span class="st">&quot;Table parsing benchmark&quot;</span>,</span>
<span id="cb16-3"><a href="#cb16-3"></a>        <span class="dt">ylab =</span> <span class="st">&quot;Milliseconds&quot;</span>)</span></code></pre></div>
<div class="figure"><span id="fig:parsing-bmark"></span>
<img src="/post/2021/03/10-mejorando-nuestro-scraping_files/figure-html/parsing-bmark-1.png" alt="Benchmark of the two table parsing methods" width="499.2" />
<p class="caption">
Figure 2: <em>Benchmark</em> of the two table parsing methods
</p>
</div>
<p>It is clear that the new method is significantly faster, as the median execution time was
halved (from 0.37 to 0.17 seconds). Hence, from now on, I will be using <code>rvest</code>
whenever <em>web scraping</em> is required. There's still room for improvement, though. I
mentioned <code>html_node()</code> has two options to specify what node should be extracted.
The second option is to write a <a href="https://www.w3schools.com/xml/xpath_intro.asp">XPath</a>
expression, which more or less works like a file's path inside a file system.</p>
<p>I am going to compare the extraction speed when using the same CSS <em>selector</em>
as before, and two XPaths. The expression <code>"//table"</code> means “look for a table
(remember, there is only one in each OSMstats page), no matter where it is”; let's say
this is the “easy” expression. With the other XPath I will specify in an exact manner
where is the table, much like I did with <code>pluck_xml()</code> in the old method; in
theory, this will be the fastest expression.</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1"></a>easy_css =<span class="st"> </span><span class="cf">function</span>(doc) <span class="kw">html_node</span>(doc, <span class="dt">css =</span> <span class="st">&quot;#countrytable&quot;</span>)</span>
<span id="cb17-2"><a href="#cb17-2"></a></span>
<span id="cb17-3"><a href="#cb17-3"></a>easy_xpath =<span class="st"> </span><span class="cf">function</span>(doc) <span class="kw">html_node</span>(doc, <span class="dt">xpath =</span> <span class="st">&quot;//table&quot;</span>)</span>
<span id="cb17-4"><a href="#cb17-4"></a></span>
<span id="cb17-5"><a href="#cb17-5"></a>exact_xpath =<span class="st"> </span><span class="cf">function</span>(doc) <span class="kw">html_node</span>(doc, <span class="dt">xpath =</span> <span class="st">&quot;body/div[3]/div[4]/div/table&quot;</span>)</span>
<span id="cb17-6"><a href="#cb17-6"></a></span>
<span id="cb17-7"><a href="#cb17-7"></a>extraction_bmark =<span class="st"> </span><span class="kw">microbenchmark</span>(<span class="kw">easy_css</span>(rvest_doc),</span>
<span id="cb17-8"><a href="#cb17-8"></a>                                  <span class="kw">easy_xpath</span>(rvest_doc),</span>
<span id="cb17-9"><a href="#cb17-9"></a>                                  <span class="kw">exact_xpath</span>(rvest_doc))</span>
<span id="cb17-10"><a href="#cb17-10"></a></span>
<span id="cb17-11"><a href="#cb17-11"></a><span class="kw">boxplot</span>(<span class="kw">filter</span>(extraction_bmark, time <span class="op">&lt;</span><span class="st"> </span><span class="fl">4.5e6</span>),</span>
<span id="cb17-12"><a href="#cb17-12"></a>        <span class="dt">main =</span> <span class="st">&quot;Table extraction benchmark&quot;</span>,</span>
<span id="cb17-13"><a href="#cb17-13"></a>        <span class="dt">ylab =</span> <span class="st">&quot;Microseconds&quot;</span>)</span></code></pre></div>
<div class="figure"><span id="fig:extraction-bmark"></span>
<img src="/post/2021/03/10-mejorando-nuestro-scraping_files/figure-html/extraction-bmark-1.png" alt="Benchmark of the three table extraction methods" width="748.8" />
<p class="caption">
Figure 3: <em>Benchmark</em> of the three table extraction methods
</p>
</div>
<p>The result is that extracting is about 2 milliseconds slower with the <em>selector</em>.
With the exact XPath expression there is a little improvement, but it is in the order of
microseconds. As a conclusion, in the future —when I need to obtain the daily created
OpenStreetMap elements again— I will apply the <code>"//table"</code> expression, which is
both fast and easy to understand.</p>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p><em>Tags</em> are the nodes or elements that make up a HTML document, like
<code>&lt;a&gt;</code> or <code>&lt;tr&gt;</code>.<a href="#fnref1" class="footnote-back">↩︎</a></p></li>
<li id="fn2"><p>In reality, in the Countries tab of OSMstats, each page shows data
corresponding to the previous day; therefore, in this example, the data is actually
from February 28.<a href="#fnref2" class="footnote-back">↩︎</a></p></li>
<li id="fn3"><p>There is also <code>rvest::html_nodes()</code> that can extract many <em>tags</em> at
once, and returns a <code>xml_nodeset</code>.<a href="#fnref3" class="footnote-back">↩︎</a></p></li>
<li id="fn4"><p><em>Selectors</em> are rules to select <em>tags</em> and apply styles in a HTML document, like
<code>a:hover { }</code> o <code>tr.odd { }</code>.<a href="#fnref4" class="footnote-back">↩︎</a></p></li>
</ol>
</div>
